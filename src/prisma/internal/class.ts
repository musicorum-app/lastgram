/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * üõë Under no circumstances should you import this file directly! üõë
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
    "previewFeatures": [],
    "clientVersion": "7.3.0",
    "engineVersion": "9d6ad21cbbceab97458517b147a6a09ff43aa735",
    "activeProvider": "postgresql",
    "inlineSchema": "datasource db {\n  provider = \"postgresql\"\n}\n\ngenerator client {\n  provider = \"prisma-client\"\n  output   = \"../src/prisma\"\n}\n\nmodel User {\n  id               Int      @id @default(autoincrement())\n  platformId       String   @unique\n  fmUsername       String\n  language         String   @default(\"en\")\n  createdAt        DateTime @default(now())\n  updatedAt        DateTime @updatedAt\n  isBanned         Boolean  @default(false)\n  revealUser       Boolean  @default(false)\n  sendPhotosAsLink Boolean  @default(false)\n  sendTags         Boolean  @default(false)\n  likedEmoji       String   @default(\"‚ù§Ô∏è\")\n  banNote          String?\n  sessionKey       String?\n}\n\nmodel FmDisplayName {\n  id          Int      @id @default(autoincrement())\n  fmUsername  String   @unique\n  displayName String\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n}\n\n/**\n * these were generated from the previous graph engine which used cassandra. they are in here for reference, as the new postgres schemas will follow a similar logic (but optimized for relational dbs)\n * model ArtistScrobble {\n * fmUsername  String   @db.Text\n * artistMbid  String   @db.Text\n * playCount   Int\n * createdAt   DateTime @default(now())\n * updatedAt   DateTime @updatedAt\n * user   User    @relation(fields: [fmUsername], references: [fmUsername])\n * crowns Crown[]\n * @@id([fmUsername, artistMbid])\n * @@map(\"artist_scrobbles\")\n * }\n * model Crown {\n * groupId       String   @db.Text\n * artistMbid    String   @db.Text\n * fmUsername    String   @db.Text\n * playCount     Int\n * switchedTimes Int      @default(0) @map(\"switchedtimes\")\n * createdAt     DateTime @default(now())\n * updatedAt     DateTime @updatedAt\n * artistScrobble ArtistScrobble @relation(fields: [fmUsername, artistMbid], references: [fmUsername, artistMbid])\n * groupMember    GroupMember    @relation(fields: [groupId, fmUsername], references: [groupId, fmUsername])\n * @@id([groupId, artistMbid])\n * @@map(\"crowns\")\n * }\n * model CrownHolder {\n * groupId    String   @db.Text\n * artistMbid String   @db.Text\n * fmUsername String   @db.Text\n * playCount  Int\n * createdAt  DateTime @default(now())\n * user User @relation(fields: [fmUsername], references: [fmUsername])\n * @@id([groupId, artistMbid, fmUsername])\n * @@map(\"crown_holders\")\n * }\n * model ArtistMbidMap {\n * artistName  String  @db.Text\n * artistMbid  String  @db.Text\n * artistCover String? @db.Text\n * @@id([artistName, artistMbid])\n * @@map(\"artist_mbid_map\")\n * }\n * model GroupMember {\n * groupId    String   @db.Text\n * fmUsername String   @db.Text\n * createdAt  DateTime @default(now())\n * updatedAt  DateTime @updatedAt\n * user   User    @relation(fields: [fmUsername], references: [fmUsername])\n * crowns Crown[]\n * @@id([groupId, fmUsername])\n * @@map(\"group_members\")\n * }\n */\n\n// Holds the artist in question. If they dont have a real MBID, we generate one by MD5ing their name\nmodel Artist {\n  mbid            String           @id\n  name            String\n  coverUrl        String?\n  createdAt       DateTime         @default(now())\n  updatedAt       DateTime         @updatedAt\n  artistScrobbles ArtistScrobble[]\n  crowns          Crown[]\n  crownHolders    CrownHolder[]\n\n  @@index([name])\n}\n\n// Holds the scrobble counts for each user-artist pair\nmodel ArtistScrobble {\n  id         Int      @id @default(autoincrement())\n  fmUsername String\n  artistId   String\n  artist     Artist   @relation(fields: [artistId], references: [mbid], onDelete: Cascade)\n  playCount  Int\n  createdAt  DateTime @default(now())\n  updatedAt  DateTime @updatedAt\n\n  @@unique([fmUsername, artistId])\n  @@index([fmUsername])\n  @@index([playCount(sort: Desc)])\n}\n\nmodel GroupMember {\n  id         Int      @id @default(autoincrement())\n  groupId    String\n  fmUsername String\n  createdAt  DateTime @default(now())\n  updatedAt  DateTime @updatedAt\n\n  @@unique([groupId, fmUsername])\n  @@index([groupId])\n  @@index([fmUsername])\n}\n\n// Holds the crown information for each group-artist pair\nmodel Crown {\n  id            Int      @id @default(autoincrement())\n  groupId       String\n  artistId      String\n  fmUsername    String // Current crown holder\n  playCount     Int // Current holder's play count\n  artist        Artist   @relation(fields: [artistId], references: [mbid], onDelete: Cascade)\n  switchedTimes Int      @default(0)\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n\n  @@unique([groupId, artistId])\n  @@index([artistId])\n  @@index([groupId])\n  @@index([fmUsername])\n}\n\nmodel CrownHolder {\n  id         Int      @id @default(autoincrement())\n  groupId    String\n  artistId   String\n  fmUsername String\n  playCount  Int\n  createdAt  DateTime @default(now())\n  artist     Artist   @relation(fields: [artistId], references: [mbid], onDelete: Cascade)\n\n  @@unique([groupId, artistId, fmUsername])\n  @@index([groupId, playCount(sort: Desc)])\n  @@index([artistId])\n  @@index([fmUsername])\n}\n",
    "runtimeDataModel": {
        "models": {},
        "enums": {},
        "types": {}
    }
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"platformId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"language\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"isBanned\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"revealUser\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"sendPhotosAsLink\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"sendTags\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"likedEmoji\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"banNote\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"sessionKey\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null},\"FmDisplayName\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"displayName\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Artist\":{\"fields\":[{\"name\":\"mbid\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"coverUrl\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"artistScrobbles\",\"kind\":\"object\",\"type\":\"ArtistScrobble\",\"relationName\":\"ArtistToArtistScrobble\"},{\"name\":\"crowns\",\"kind\":\"object\",\"type\":\"Crown\",\"relationName\":\"ArtistToCrown\"},{\"name\":\"crownHolders\",\"kind\":\"object\",\"type\":\"CrownHolder\",\"relationName\":\"ArtistToCrownHolder\"}],\"dbName\":null},\"ArtistScrobble\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"artistId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"artist\",\"kind\":\"object\",\"type\":\"Artist\",\"relationName\":\"ArtistToArtistScrobble\"},{\"name\":\"playCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"GroupMember\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"groupId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"Crown\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"groupId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"artistId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"playCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"artist\",\"kind\":\"object\",\"type\":\"Artist\",\"relationName\":\"ArtistToCrown\"},{\"name\":\"switchedTimes\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":null},\"CrownHolder\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"groupId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"artistId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"fmUsername\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"playCount\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"artist\",\"kind\":\"object\",\"type\":\"Artist\",\"relationName\":\"ArtistToCrownHolder\"}],\"dbName\":null}},\"enums\":{},\"types\":{}}")

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
    const { Buffer } = await import('node:buffer')
    const wasmArray = Buffer.from(wasmBase64, 'base64')
    return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
    getRuntime: async () => await import("@prisma/client/runtime/query_compiler_fast_bg.postgresql.mjs"),

    getQueryCompilerWasmModule: async () => {
        const { wasm } = await import("@prisma/client/runtime/query_compiler_fast_bg.postgresql.wasm-base64.mjs")
        return await decodeBase64AsWasm(wasm)
    },

    importName: "./query_compiler_fast_bg.js"
}


export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
    'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
     * ## Prisma Client
     *
     * Type-safe database client for TypeScript
     * @example
     * ```
     * const prisma = new PrismaClient()
     * // Fetch zero or more Users
     * const users = await prisma.user.findMany()
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/client).
     */

    new<
        Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
        LogOpts extends LogOptions<Options> = LogOptions<Options>,
        OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends {
            omit: infer U
        } ? U : Prisma.PrismaClientOptions['omit'],
        ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
    >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions>): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 *
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
    in LogOpts extends Prisma.LogLevel = never,
    in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,
    in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
    $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
        extArgs: ExtArgs
    }>>

    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

    /**
     * Connect with the database
     */
    $connect(): runtime.Types.Utils.JsPromise<void>;

    /**
     * Disconnect from the database
     */
    $disconnect(): runtime.Types.Utils.JsPromise<void>;

    /**
     * Executes a prepared raw query and returns the number of affected rows.
     * @example
     * ```
     * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

    /**
     * Executes a raw query and returns the number of affected rows.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

    /**
     * Performs a prepared raw query and returns the `SELECT` data.
     * @example
     * ```
     * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

    /**
     * Performs a raw query and returns the `SELECT` data.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

    /**
     * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
     * @example
     * ```
     * const [george, bob, alice] = await prisma.$transaction([
     *   prisma.user.create({ data: { name: 'George' } }),
     *   prisma.user.create({ data: { name: 'Bob' } }),
     *   prisma.user.create({ data: { name: 'Alice' } }),
     * ])
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
     */
    $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: {
        isolationLevel?: Prisma.TransactionIsolationLevel
    }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

    $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: {
        maxWait?: number,
        timeout?: number,
        isolationLevel?: Prisma.TransactionIsolationLevel
    }): runtime.Types.Utils.JsPromise<R>

    /**
     * `prisma.user`: Exposes CRUD operations for the **User** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Users
     * const users = await prisma.user.findMany()
     * ```
     */
    get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.fmDisplayName`: Exposes CRUD operations for the **FmDisplayName** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more FmDisplayNames
     * const fmDisplayNames = await prisma.fmDisplayName.findMany()
     * ```
     */
    get fmDisplayName(): Prisma.FmDisplayNameDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.artist`: Exposes CRUD operations for the **Artist** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Artists
     * const artists = await prisma.artist.findMany()
     * ```
     */
    get artist(): Prisma.ArtistDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.artistScrobble`: Exposes CRUD operations for the **ArtistScrobble** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more ArtistScrobbles
     * const artistScrobbles = await prisma.artistScrobble.findMany()
     * ```
     */
    get artistScrobble(): Prisma.ArtistScrobbleDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * ```
     */
    get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.crown`: Exposes CRUD operations for the **Crown** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Crowns
     * const crowns = await prisma.crown.findMany()
     * ```
     */
    get crown(): Prisma.CrownDelegate<ExtArgs, { omit: OmitOpts }>;

    /**
     * `prisma.crownHolder`: Exposes CRUD operations for the **CrownHolder** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more CrownHolders
     * const crownHolders = await prisma.crownHolder.findMany()
     * ```
     */
    get crownHolder(): Prisma.CrownHolderDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(): PrismaClientConstructor {
    return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
