/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Artist` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Artist
 *
 */
export type ArtistModel = runtime.Types.Result.DefaultSelection<Prisma.$ArtistPayload>

export type AggregateArtist = {
    _count: ArtistCountAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
}

export type ArtistMinAggregateOutputType = {
    mbid: string | null
    name: string | null
    coverUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
}

export type ArtistMaxAggregateOutputType = {
    mbid: string | null
    name: string | null
    coverUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
}

export type ArtistCountAggregateOutputType = {
    mbid: number
    name: number
    coverUrl: number
    createdAt: number
    updatedAt: number
    _all: number
}


export type ArtistMinAggregateInputType = {
    mbid?: true
    name?: true
    coverUrl?: true
    createdAt?: true
    updatedAt?: true
}

export type ArtistMaxAggregateInputType = {
    mbid?: true
    name?: true
    coverUrl?: true
    createdAt?: true
    updatedAt?: true
}

export type ArtistCountAggregateInputType = {
    mbid?: true
    name?: true
    coverUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
}

export type ArtistAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Artist to aggregate.
     */
    where?: Prisma.ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artists to fetch.
     */
    orderBy?: Prisma.ArtistOrderByWithRelationInput | Prisma.ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Artists
     **/
    _count?: true | ArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ArtistMaxAggregateInputType
}

export type GetArtistAggregateType<T extends ArtistAggregateArgs> = {
    [P in keyof T & keyof AggregateArtist]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateArtist[P]>
        : Prisma.GetScalarType<T[P], AggregateArtist[P]>
}


export type ArtistGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.ArtistWhereInput
    orderBy?: Prisma.ArtistOrderByWithAggregationInput | Prisma.ArtistOrderByWithAggregationInput[]
    by: Prisma.ArtistScalarFieldEnum[] | Prisma.ArtistScalarFieldEnum
    having?: Prisma.ArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistCountAggregateInputType | true
    _min?: ArtistMinAggregateInputType
    _max?: ArtistMaxAggregateInputType
}

export type ArtistGroupByOutputType = {
    mbid: string
    name: string
    coverUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ArtistCountAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
}

type GetArtistGroupByPayload<T extends ArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<ArtistGroupByOutputType, T['by']> &
        {
            [P in ((keyof T) & (keyof ArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
                ? number
                : Prisma.GetScalarType<T[P], ArtistGroupByOutputType[P]>
            : Prisma.GetScalarType<T[P], ArtistGroupByOutputType[P]>
        }
    >
>


export type ArtistWhereInput = {
    AND?: Prisma.ArtistWhereInput | Prisma.ArtistWhereInput[]
    OR?: Prisma.ArtistWhereInput[]
    NOT?: Prisma.ArtistWhereInput | Prisma.ArtistWhereInput[]
    mbid?: Prisma.StringFilter<"Artist"> | string
    name?: Prisma.StringFilter<"Artist"> | string
    coverUrl?: Prisma.StringNullableFilter<"Artist"> | string | null
    createdAt?: Prisma.DateTimeFilter<"Artist"> | Date | string
    updatedAt?: Prisma.DateTimeFilter<"Artist"> | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleListRelationFilter
    crowns?: Prisma.CrownListRelationFilter
    crownHolders?: Prisma.CrownHolderListRelationFilter
}

export type ArtistOrderByWithRelationInput = {
    mbid?: Prisma.SortOrder
    name?: Prisma.SortOrder
    coverUrl?: Prisma.SortOrderInput | Prisma.SortOrder
    createdAt?: Prisma.SortOrder
    updatedAt?: Prisma.SortOrder
    artistScrobbles?: Prisma.ArtistScrobbleOrderByRelationAggregateInput
    crowns?: Prisma.CrownOrderByRelationAggregateInput
    crownHolders?: Prisma.CrownHolderOrderByRelationAggregateInput
}

export type ArtistWhereUniqueInput = Prisma.AtLeast<{
    mbid?: string
    AND?: Prisma.ArtistWhereInput | Prisma.ArtistWhereInput[]
    OR?: Prisma.ArtistWhereInput[]
    NOT?: Prisma.ArtistWhereInput | Prisma.ArtistWhereInput[]
    name?: Prisma.StringFilter<"Artist"> | string
    coverUrl?: Prisma.StringNullableFilter<"Artist"> | string | null
    createdAt?: Prisma.DateTimeFilter<"Artist"> | Date | string
    updatedAt?: Prisma.DateTimeFilter<"Artist"> | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleListRelationFilter
    crowns?: Prisma.CrownListRelationFilter
    crownHolders?: Prisma.CrownHolderListRelationFilter
}, "mbid">

export type ArtistOrderByWithAggregationInput = {
    mbid?: Prisma.SortOrder
    name?: Prisma.SortOrder
    coverUrl?: Prisma.SortOrderInput | Prisma.SortOrder
    createdAt?: Prisma.SortOrder
    updatedAt?: Prisma.SortOrder
    _count?: Prisma.ArtistCountOrderByAggregateInput
    _max?: Prisma.ArtistMaxOrderByAggregateInput
    _min?: Prisma.ArtistMinOrderByAggregateInput
}

export type ArtistScalarWhereWithAggregatesInput = {
    AND?: Prisma.ArtistScalarWhereWithAggregatesInput | Prisma.ArtistScalarWhereWithAggregatesInput[]
    OR?: Prisma.ArtistScalarWhereWithAggregatesInput[]
    NOT?: Prisma.ArtistScalarWhereWithAggregatesInput | Prisma.ArtistScalarWhereWithAggregatesInput[]
    mbid?: Prisma.StringWithAggregatesFilter<"Artist"> | string
    name?: Prisma.StringWithAggregatesFilter<"Artist"> | string
    coverUrl?: Prisma.StringNullableWithAggregatesFilter<"Artist"> | string | null
    createdAt?: Prisma.DateTimeWithAggregatesFilter<"Artist"> | Date | string
    updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Artist"> | Date | string
}

export type ArtistCreateInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleCreateNestedManyWithoutArtistInput
    crowns?: Prisma.CrownCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderCreateNestedManyWithoutArtistInput
}

export type ArtistUncheckedCreateInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedCreateNestedManyWithoutArtistInput
    crowns?: Prisma.CrownUncheckedCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderUncheckedCreateNestedManyWithoutArtistInput
}

export type ArtistUpdateInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUpdateManyWithoutArtistNestedInput
    crowns?: Prisma.CrownUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUpdateManyWithoutArtistNestedInput
}

export type ArtistUncheckedUpdateInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedUpdateManyWithoutArtistNestedInput
    crowns?: Prisma.CrownUncheckedUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUncheckedUpdateManyWithoutArtistNestedInput
}

export type ArtistCreateManyInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
}

export type ArtistUpdateManyMutationInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ArtistUncheckedUpdateManyInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ArtistCountOrderByAggregateInput = {
    mbid?: Prisma.SortOrder
    name?: Prisma.SortOrder
    coverUrl?: Prisma.SortOrder
    createdAt?: Prisma.SortOrder
    updatedAt?: Prisma.SortOrder
}

export type ArtistMaxOrderByAggregateInput = {
    mbid?: Prisma.SortOrder
    name?: Prisma.SortOrder
    coverUrl?: Prisma.SortOrder
    createdAt?: Prisma.SortOrder
    updatedAt?: Prisma.SortOrder
}

export type ArtistMinOrderByAggregateInput = {
    mbid?: Prisma.SortOrder
    name?: Prisma.SortOrder
    coverUrl?: Prisma.SortOrder
    createdAt?: Prisma.SortOrder
    updatedAt?: Prisma.SortOrder
}

export type ArtistScalarRelationFilter = {
    is?: Prisma.ArtistWhereInput
    isNot?: Prisma.ArtistWhereInput
}

export type ArtistCreateNestedOneWithoutArtistScrobblesInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedCreateWithoutArtistScrobblesInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutArtistScrobblesInput
    connect?: Prisma.ArtistWhereUniqueInput
}

export type ArtistUpdateOneRequiredWithoutArtistScrobblesNestedInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedCreateWithoutArtistScrobblesInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutArtistScrobblesInput
    upsert?: Prisma.ArtistUpsertWithoutArtistScrobblesInput
    connect?: Prisma.ArtistWhereUniqueInput
    update?: Prisma.XOR<Prisma.XOR<Prisma.ArtistUpdateToOneWithWhereWithoutArtistScrobblesInput, Prisma.ArtistUpdateWithoutArtistScrobblesInput>, Prisma.ArtistUncheckedUpdateWithoutArtistScrobblesInput>
}

export type ArtistCreateNestedOneWithoutCrownsInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutCrownsInput, Prisma.ArtistUncheckedCreateWithoutCrownsInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutCrownsInput
    connect?: Prisma.ArtistWhereUniqueInput
}

export type ArtistUpdateOneRequiredWithoutCrownsNestedInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutCrownsInput, Prisma.ArtistUncheckedCreateWithoutCrownsInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutCrownsInput
    upsert?: Prisma.ArtistUpsertWithoutCrownsInput
    connect?: Prisma.ArtistWhereUniqueInput
    update?: Prisma.XOR<Prisma.XOR<Prisma.ArtistUpdateToOneWithWhereWithoutCrownsInput, Prisma.ArtistUpdateWithoutCrownsInput>, Prisma.ArtistUncheckedUpdateWithoutCrownsInput>
}

export type ArtistCreateNestedOneWithoutCrownHoldersInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutCrownHoldersInput, Prisma.ArtistUncheckedCreateWithoutCrownHoldersInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutCrownHoldersInput
    connect?: Prisma.ArtistWhereUniqueInput
}

export type ArtistUpdateOneRequiredWithoutCrownHoldersNestedInput = {
    create?: Prisma.XOR<Prisma.ArtistCreateWithoutCrownHoldersInput, Prisma.ArtistUncheckedCreateWithoutCrownHoldersInput>
    connectOrCreate?: Prisma.ArtistCreateOrConnectWithoutCrownHoldersInput
    upsert?: Prisma.ArtistUpsertWithoutCrownHoldersInput
    connect?: Prisma.ArtistWhereUniqueInput
    update?: Prisma.XOR<Prisma.XOR<Prisma.ArtistUpdateToOneWithWhereWithoutCrownHoldersInput, Prisma.ArtistUpdateWithoutCrownHoldersInput>, Prisma.ArtistUncheckedUpdateWithoutCrownHoldersInput>
}

export type ArtistCreateWithoutArtistScrobblesInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crowns?: Prisma.CrownCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderCreateNestedManyWithoutArtistInput
}

export type ArtistUncheckedCreateWithoutArtistScrobblesInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    crowns?: Prisma.CrownUncheckedCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderUncheckedCreateNestedManyWithoutArtistInput
}

export type ArtistCreateOrConnectWithoutArtistScrobblesInput = {
    where: Prisma.ArtistWhereUniqueInput
    create: Prisma.XOR<Prisma.ArtistCreateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedCreateWithoutArtistScrobblesInput>
}

export type ArtistUpsertWithoutArtistScrobblesInput = {
    update: Prisma.XOR<Prisma.ArtistUpdateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedUpdateWithoutArtistScrobblesInput>
    create: Prisma.XOR<Prisma.ArtistCreateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedCreateWithoutArtistScrobblesInput>
    where?: Prisma.ArtistWhereInput
}

export type ArtistUpdateToOneWithWhereWithoutArtistScrobblesInput = {
    where?: Prisma.ArtistWhereInput
    data: Prisma.XOR<Prisma.ArtistUpdateWithoutArtistScrobblesInput, Prisma.ArtistUncheckedUpdateWithoutArtistScrobblesInput>
}

export type ArtistUpdateWithoutArtistScrobblesInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    crowns?: Prisma.CrownUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUpdateManyWithoutArtistNestedInput
}

export type ArtistUncheckedUpdateWithoutArtistScrobblesInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    crowns?: Prisma.CrownUncheckedUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUncheckedUpdateManyWithoutArtistNestedInput
}

export type ArtistCreateWithoutCrownsInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderCreateNestedManyWithoutArtistInput
}

export type ArtistUncheckedCreateWithoutCrownsInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedCreateNestedManyWithoutArtistInput
    crownHolders?: Prisma.CrownHolderUncheckedCreateNestedManyWithoutArtistInput
}

export type ArtistCreateOrConnectWithoutCrownsInput = {
    where: Prisma.ArtistWhereUniqueInput
    create: Prisma.XOR<Prisma.ArtistCreateWithoutCrownsInput, Prisma.ArtistUncheckedCreateWithoutCrownsInput>
}

export type ArtistUpsertWithoutCrownsInput = {
    update: Prisma.XOR<Prisma.ArtistUpdateWithoutCrownsInput, Prisma.ArtistUncheckedUpdateWithoutCrownsInput>
    create: Prisma.XOR<Prisma.ArtistCreateWithoutCrownsInput, Prisma.ArtistUncheckedCreateWithoutCrownsInput>
    where?: Prisma.ArtistWhereInput
}

export type ArtistUpdateToOneWithWhereWithoutCrownsInput = {
    where?: Prisma.ArtistWhereInput
    data: Prisma.XOR<Prisma.ArtistUpdateWithoutCrownsInput, Prisma.ArtistUncheckedUpdateWithoutCrownsInput>
}

export type ArtistUpdateWithoutCrownsInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUpdateManyWithoutArtistNestedInput
}

export type ArtistUncheckedUpdateWithoutCrownsInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedUpdateManyWithoutArtistNestedInput
    crownHolders?: Prisma.CrownHolderUncheckedUpdateManyWithoutArtistNestedInput
}

export type ArtistCreateWithoutCrownHoldersInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleCreateNestedManyWithoutArtistInput
    crowns?: Prisma.CrownCreateNestedManyWithoutArtistInput
}

export type ArtistUncheckedCreateWithoutCrownHoldersInput = {
    mbid: string
    name: string
    coverUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedCreateNestedManyWithoutArtistInput
    crowns?: Prisma.CrownUncheckedCreateNestedManyWithoutArtistInput
}

export type ArtistCreateOrConnectWithoutCrownHoldersInput = {
    where: Prisma.ArtistWhereUniqueInput
    create: Prisma.XOR<Prisma.ArtistCreateWithoutCrownHoldersInput, Prisma.ArtistUncheckedCreateWithoutCrownHoldersInput>
}

export type ArtistUpsertWithoutCrownHoldersInput = {
    update: Prisma.XOR<Prisma.ArtistUpdateWithoutCrownHoldersInput, Prisma.ArtistUncheckedUpdateWithoutCrownHoldersInput>
    create: Prisma.XOR<Prisma.ArtistCreateWithoutCrownHoldersInput, Prisma.ArtistUncheckedCreateWithoutCrownHoldersInput>
    where?: Prisma.ArtistWhereInput
}

export type ArtistUpdateToOneWithWhereWithoutCrownHoldersInput = {
    where?: Prisma.ArtistWhereInput
    data: Prisma.XOR<Prisma.ArtistUpdateWithoutCrownHoldersInput, Prisma.ArtistUncheckedUpdateWithoutCrownHoldersInput>
}

export type ArtistUpdateWithoutCrownHoldersInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUpdateManyWithoutArtistNestedInput
    crowns?: Prisma.CrownUpdateManyWithoutArtistNestedInput
}

export type ArtistUncheckedUpdateWithoutCrownHoldersInput = {
    mbid?: Prisma.StringFieldUpdateOperationsInput | string
    name?: Prisma.StringFieldUpdateOperationsInput | string
    coverUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    artistScrobbles?: Prisma.ArtistScrobbleUncheckedUpdateManyWithoutArtistNestedInput
    crowns?: Prisma.CrownUncheckedUpdateManyWithoutArtistNestedInput
}


/**
 * Count Type ArtistCountOutputType
 */

export type ArtistCountOutputType = {
    artistScrobbles: number
    crowns: number
    crownHolders: number
}

export type ArtistCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    artistScrobbles?: boolean | ArtistCountOutputTypeCountArtistScrobblesArgs
    crowns?: boolean | ArtistCountOutputTypeCountCrownsArgs
    crownHolders?: boolean | ArtistCountOutputTypeCountCrownHoldersArgs
}

/**
 * ArtistCountOutputType without action
 */
export type ArtistCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistCountOutputType
     */
    select?: Prisma.ArtistCountOutputTypeSelect<ExtArgs> | null
}

/**
 * ArtistCountOutputType without action
 */
export type ArtistCountOutputTypeCountArtistScrobblesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.ArtistScrobbleWhereInput
}

/**
 * ArtistCountOutputType without action
 */
export type ArtistCountOutputTypeCountCrownsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.CrownWhereInput
}

/**
 * ArtistCountOutputType without action
 */
export type ArtistCountOutputTypeCountCrownHoldersArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.CrownHolderWhereInput
}


export type ArtistSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    mbid?: boolean
    name?: boolean
    coverUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artistScrobbles?: boolean | Prisma.Artist$artistScrobblesArgs<ExtArgs>
    crowns?: boolean | Prisma.Artist$crownsArgs<ExtArgs>
    crownHolders?: boolean | Prisma.Artist$crownHoldersArgs<ExtArgs>
    _count?: boolean | Prisma.ArtistCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["artist"]>

export type ArtistSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    mbid?: boolean
    name?: boolean
    coverUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
}, ExtArgs["result"]["artist"]>

export type ArtistSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    mbid?: boolean
    name?: boolean
    coverUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
}, ExtArgs["result"]["artist"]>

export type ArtistSelectScalar = {
    mbid?: boolean
    name?: boolean
    coverUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
}

export type ArtistOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"mbid" | "name" | "coverUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["artist"]>
export type ArtistInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    artistScrobbles?: boolean | Prisma.Artist$artistScrobblesArgs<ExtArgs>
    crowns?: boolean | Prisma.Artist$crownsArgs<ExtArgs>
    crownHolders?: boolean | Prisma.Artist$crownHoldersArgs<ExtArgs>
    _count?: boolean | Prisma.ArtistCountOutputTypeDefaultArgs<ExtArgs>
}
export type ArtistIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type ArtistIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $ArtistPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Artist"
    objects: {
        artistScrobbles: Prisma.$ArtistScrobblePayload<ExtArgs>[]
        crowns: Prisma.$CrownPayload<ExtArgs>[]
        crownHolders: Prisma.$CrownHolderPayload<ExtArgs>[]
    }
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        mbid: string
        name: string
        coverUrl: string | null
        createdAt: Date
        updatedAt: Date
    }, ExtArgs["result"]["artist"]>
    composites: {}
}

export type ArtistGetPayload<S extends boolean | null | undefined | ArtistDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ArtistPayload, S>

export type ArtistCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    Omit<ArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ArtistCountAggregateInputType | true
}

export interface ArtistDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    /**
     * Fields of the Artist model
     */
    readonly fields: ArtistFieldRefs;

    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artist'], meta: { name: 'Artist' } }

    /**
     * Find zero or one Artist that matches the filter.
     * @param {ArtistFindUniqueArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistFindUniqueArgs>(args: Prisma.SelectSubset<T, ArtistFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistFindUniqueOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistFindFirstArgs>(args?: Prisma.SelectSubset<T, ArtistFindFirstArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artists
     * const artists = await prisma.artist.findMany()
     *
     * // Get first 10 Artists
     * const artists = await prisma.artist.findMany({ take: 10 })
     *
     * // Only select the `mbid`
     * const artistWithMbidOnly = await prisma.artist.findMany({ select: { mbid: true } })
     *
     */
    findMany<T extends ArtistFindManyArgs>(args?: Prisma.SelectSubset<T, ArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artist.
     * @param {ArtistCreateArgs} args - Arguments to create a Artist.
     * @example
     * // Create one Artist
     * const Artist = await prisma.artist.create({
     *   data: {
     *     // ... data to create a Artist
     *   }
     * })
     *
     */
    create<T extends ArtistCreateArgs>(args: Prisma.SelectSubset<T, ArtistCreateArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artists.
     * @param {ArtistCreateManyArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArtistCreateManyArgs>(args?: Prisma.SelectSubset<T, ArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Create many Artists and returns the data saved in the database.
     * @param {ArtistCreateManyAndReturnArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Artists and only return the `mbid`
     * const artistWithMbidOnly = await prisma.artist.createManyAndReturn({
     *   select: { mbid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArtistCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artist.
     * @param {ArtistDeleteArgs} args - Arguments to delete one Artist.
     * @example
     * // Delete one Artist
     * const Artist = await prisma.artist.delete({
     *   where: {
     *     // ... filter to delete one Artist
     *   }
     * })
     *
     */
    delete<T extends ArtistDeleteArgs>(args: Prisma.SelectSubset<T, ArtistDeleteArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artist.
     * @param {ArtistUpdateArgs} args - Arguments to update one Artist.
     * @example
     * // Update one Artist
     * const artist = await prisma.artist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArtistUpdateArgs>(args: Prisma.SelectSubset<T, ArtistUpdateArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artists.
     * @param {ArtistDeleteManyArgs} args - Arguments to filter Artists to delete.
     * @example
     * // Delete a few Artists
     * const { count } = await prisma.artist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArtistDeleteManyArgs>(args?: Prisma.SelectSubset<T, ArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Update zero or more Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArtistUpdateManyArgs>(args: Prisma.SelectSubset<T, ArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Update zero or more Artists and returns the data updated in the database.
     * @param {ArtistUpdateManyAndReturnArgs} args - Arguments to update many Artists.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Artists and only return the `mbid`
     * const artistWithMbidOnly = await prisma.artist.updateManyAndReturn({
     *   select: { mbid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArtistUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artist.
     * @param {ArtistUpsertArgs} args - Arguments to update or create a Artist.
     * @example
     * // Update or create a Artist
     * const artist = await prisma.artist.upsert({
     *   create: {
     *     // ... data to create a Artist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artist we want to update
     *   }
     * })
     */
    upsert<T extends ArtistUpsertArgs>(args: Prisma.SelectSubset<T, ArtistUpsertArgs<ExtArgs>>): Prisma.Prisma__ArtistClient<runtime.Types.Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Count the number of Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistCountArgs} args - Arguments to filter Artists to count.
     * @example
     * // Count the number of Artists
     * const count = await prisma.artist.count({
     *   where: {
     *     // ... the filter for the Artists we want to count
     *   }
     * })
     **/
    count<T extends ArtistCountArgs>(
        args?: Prisma.Subset<T, ArtistCountArgs>,
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<T['select'], ArtistCountAggregateOutputType>
            : number
    >

    /**
     * Allows you to perform aggregations operations on a Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ArtistAggregateArgs>(args: Prisma.Subset<T, ArtistAggregateArgs>): Prisma.PrismaPromise<GetArtistAggregateType<T>>

    /**
     * Group by Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends ArtistGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<'skip', Prisma.Keys<T>>,
            Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: ArtistGroupByArgs['orderBy'] }
            : { orderBy?: ArtistGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
                ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                            : [
                                Error,
                                'Field ',
                                P,
                                ` in "having" needs to be provided in "by"`,
                            ]
                }[HavingFields]
                : 'take' extends Prisma.Keys<T>
                    ? 'orderBy' extends Prisma.Keys<T>
                        ? ByValid extends Prisma.True
                            ? {}
                            : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                            }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Prisma.Keys<T>
                        ? 'orderBy' extends Prisma.Keys<T>
                            ? ByValid extends Prisma.True
                                ? {}
                                : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                            : 'Error: If you provide "skip", you also need to provide "orderBy"'
                        : ByValid extends Prisma.True
                            ? {}
                            : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                            }[OrderFields]
    >(args: Prisma.SubsetIntersection<T, ArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
}

/**
 * The delegate class that acts as a "Promise-like" for Artist.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ArtistClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"

    artistScrobbles<T extends Prisma.Artist$artistScrobblesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Artist$artistScrobblesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArtistScrobblePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>

    crowns<T extends Prisma.Artist$crownsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Artist$crownsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CrownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>

    crownHolders<T extends Prisma.Artist$crownHoldersArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Artist$crownHoldersArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CrownHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>

    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>

    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}


/**
 * Fields of the Artist model
 */
export interface ArtistFieldRefs {
    readonly mbid: Prisma.FieldRef<"Artist", 'String'>
    readonly name: Prisma.FieldRef<"Artist", 'String'>
    readonly coverUrl: Prisma.FieldRef<"Artist", 'String'>
    readonly createdAt: Prisma.FieldRef<"Artist", 'DateTime'>
    readonly updatedAt: Prisma.FieldRef<"Artist", 'DateTime'>
}


// Custom InputTypes
/**
 * Artist findUnique
 */
export type ArtistFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: Prisma.ArtistWhereUniqueInput
}

/**
 * Artist findUniqueOrThrow
 */
export type ArtistFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: Prisma.ArtistWhereUniqueInput
}

/**
 * Artist findFirst
 */
export type ArtistFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: Prisma.ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artists to fetch.
     */
    orderBy?: Prisma.ArtistOrderByWithRelationInput | Prisma.ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Artists.
     */
    cursor?: Prisma.ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Artists.
     */
    distinct?: Prisma.ArtistScalarFieldEnum | Prisma.ArtistScalarFieldEnum[]
}

/**
 * Artist findFirstOrThrow
 */
export type ArtistFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: Prisma.ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artists to fetch.
     */
    orderBy?: Prisma.ArtistOrderByWithRelationInput | Prisma.ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Artists.
     */
    cursor?: Prisma.ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Artists.
     */
    distinct?: Prisma.ArtistScalarFieldEnum | Prisma.ArtistScalarFieldEnum[]
}

/**
 * Artist findMany
 */
export type ArtistFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artists to fetch.
     */
    where?: Prisma.ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Artists to fetch.
     */
    orderBy?: Prisma.ArtistOrderByWithRelationInput | Prisma.ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Artists.
     */
    cursor?: Prisma.ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Artists.
     */
    skip?: number
    distinct?: Prisma.ArtistScalarFieldEnum | Prisma.ArtistScalarFieldEnum[]
}

/**
 * Artist create
 */
export type ArtistCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a Artist.
     */
    data: Prisma.XOR<Prisma.ArtistCreateInput, Prisma.ArtistUncheckedCreateInput>
}

/**
 * Artist createMany
 */
export type ArtistCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artists.
     */
    data: Prisma.ArtistCreateManyInput | Prisma.ArtistCreateManyInput[]
    skipDuplicates?: boolean
}

/**
 * Artist createManyAndReturn
 */
export type ArtistCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * The data used to create many Artists.
     */
    data: Prisma.ArtistCreateManyInput | Prisma.ArtistCreateManyInput[]
    skipDuplicates?: boolean
}

/**
 * Artist update
 */
export type ArtistUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a Artist.
     */
    data: Prisma.XOR<Prisma.ArtistUpdateInput, Prisma.ArtistUncheckedUpdateInput>
    /**
     * Choose, which Artist to update.
     */
    where: Prisma.ArtistWhereUniqueInput
}

/**
 * Artist updateMany
 */
export type ArtistUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Artists.
     */
    data: Prisma.XOR<Prisma.ArtistUpdateManyMutationInput, Prisma.ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: Prisma.ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
}

/**
 * Artist updateManyAndReturn
 */
export type ArtistUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * The data used to update Artists.
     */
    data: Prisma.XOR<Prisma.ArtistUpdateManyMutationInput, Prisma.ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: Prisma.ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
}

/**
 * Artist upsert
 */
export type ArtistUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the Artist to update in case it exists.
     */
    where: Prisma.ArtistWhereUniqueInput
    /**
     * In case the Artist found by the `where` argument doesn't exist, create a new Artist with this data.
     */
    create: Prisma.XOR<Prisma.ArtistCreateInput, Prisma.ArtistUncheckedCreateInput>
    /**
     * In case the Artist was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<Prisma.ArtistUpdateInput, Prisma.ArtistUncheckedUpdateInput>
}

/**
 * Artist delete
 */
export type ArtistDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
    /**
     * Filter which Artist to delete.
     */
    where: Prisma.ArtistWhereUniqueInput
}

/**
 * Artist deleteMany
 */
export type ArtistDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Artists to delete
     */
    where?: Prisma.ArtistWhereInput
    /**
     * Limit how many Artists to delete.
     */
    limit?: number
}

/**
 * Artist.artistScrobbles
 */
export type Artist$artistScrobblesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistScrobble
     */
    select?: Prisma.ArtistScrobbleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistScrobble
     */
    omit?: Prisma.ArtistScrobbleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistScrobbleInclude<ExtArgs> | null
    where?: Prisma.ArtistScrobbleWhereInput
    orderBy?: Prisma.ArtistScrobbleOrderByWithRelationInput | Prisma.ArtistScrobbleOrderByWithRelationInput[]
    cursor?: Prisma.ArtistScrobbleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prisma.ArtistScrobbleScalarFieldEnum | Prisma.ArtistScrobbleScalarFieldEnum[]
}

/**
 * Artist.crowns
 */
export type Artist$crownsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crown
     */
    select?: Prisma.CrownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crown
     */
    omit?: Prisma.CrownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.CrownInclude<ExtArgs> | null
    where?: Prisma.CrownWhereInput
    orderBy?: Prisma.CrownOrderByWithRelationInput | Prisma.CrownOrderByWithRelationInput[]
    cursor?: Prisma.CrownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prisma.CrownScalarFieldEnum | Prisma.CrownScalarFieldEnum[]
}

/**
 * Artist.crownHolders
 */
export type Artist$crownHoldersArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrownHolder
     */
    select?: Prisma.CrownHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrownHolder
     */
    omit?: Prisma.CrownHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.CrownHolderInclude<ExtArgs> | null
    where?: Prisma.CrownHolderWhereInput
    orderBy?: Prisma.CrownHolderOrderByWithRelationInput | Prisma.CrownHolderOrderByWithRelationInput[]
    cursor?: Prisma.CrownHolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prisma.CrownHolderScalarFieldEnum | Prisma.CrownHolderScalarFieldEnum[]
}

/**
 * Artist without action
 */
export type ArtistDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: Prisma.ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: Prisma.ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ArtistInclude<ExtArgs> | null
}
